#### **进程与线程**

进程结构：代码段--存放程序代码，及一部分常量

​					数据段--存放程序的全局变量和静态变量，bss未初始化或初始化为0的，data已初始化的非0的

​					堆栈段--用于函数调用，存放函数参数、局部变量

竞争条件：两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序。

互斥：以某种手段确保当一个进程再使用一个共享变量或文件时，其他进程不能同样操作。

​	方案：屏蔽中断--进程进入临界区后，所在CPU屏蔽所有中断。

​				锁变量--共享一个（锁）变量，进入临界区前，读锁，写锁再进临界区。

​				严格轮换法--轮流进入临界区，变量turn记录轮到谁可以进入。忙等待、快等慢进程

临界区：对共享内存进行访问的程序片段。

信号量：累计唤醒次数。

原子操作：一组相关联的操作要么都不间断地执行（不能被打断），要么都不执行。

二元信号量：供两个或多个进程使用的信号量，初值为1，保证同时只有一个进程可以进入临界区

互斥量：无计数能力的信号量，处于解锁（临界区可用）或加锁状态（临界区不可用）。

条件变量：允许线程由于一些未达到的条件而阻塞。

死锁：多个进程因竞争资源而造成的互相等待，无法进行有效工作。

​		原因-系统资源不足，资源分配不当，进程推进的顺序不合适（互斥、不可剥夺、请求与保持、环路等待）

管程：由过程、变量及数据结构等组成的一个集合。

调度程序：完成选择下一个要运行的进程的程序。

并发：单个CPU不停的再多个任务中来回快速切换，同一时刻只能处理一个任务

并行：一个多核CPU同时处理多个任务

#### 进程间通信

管道--一种两个进程间进行单向通信的机制，半双工， 本质是一种文件，无名管道只能用于具有亲缘关系的通信，命名管道可以非亲

系统IPC：

​				消息队列--在系统内核中建立一个保存消息的队列

​				共享内存--专门设立一块数据内存让两个进程共享

​				信号量--本质上是一个计数器，不以传送数据为主要目的，主要用来保护共享资源

​				信号--Linux中唯一的异步通讯方式，模拟中断，进程收到信号时跳入信号处理函数，执行完在跳回原来的位置继续执行

socket套接字：多机通信，支持TCP/IP网络通信的基本操作单元

#### 线程间通信

互斥锁

信号量

条件变量

读写锁

​				



#### 内存管理

​		虚拟内存机制：使得不同的进程在运行过程中，所看到的是自己独占4G空间，每个进程在虚拟内存中分配代码段、数据段，再把自己的虚拟内存空间映射并存储到物理内存中

​		内存使用与分段：程序分为代码段、数据段、堆栈段，在物理内存中分段放置，段面向用户

​		内存分区与分页：操作系统将整个物理内存以4K为单位分页，进行内存分配时都以页为单位，页面向硬件

​		多级页表与快表：页表内容为虚拟地址到物理地址的映射，单级页表占空间大且访问慢，多级页表利用快表进一步提高访问效率，快表利用TLB寄存器，将最近使用的页表记录，加快访问（程序地址访问存在局部性，多体现为循环、顺序结构）。

​		段页配合：地址翻译使虚拟内存映射至物理内存， 逻辑地址--段》虚拟地址--页》物理地址

​		内存换入：请求调页，当虚拟地址对应的物理地址不在内存中，无法映射时，产生缺页中断，请求调页，从磁盘中将对应物理地址调入。

​		内存换出：内存满了，虚拟地址依旧需要映射，则需要请求换页，将内存中的页换出。

​							LRU页面置换（least recent use）--选择最近最少使用的页淘汰，实现代价大（时间戳或栈维护）

​							LRU近似实现clock算法--将时间计数变为是和否，每页加一个引用位，访问页时硬件将该位置一，选择淘汰时扫描引用位，为1则置零，为零则淘汰。

​							CPU颠簸：系统进程增多内存中缺页率增大，达到一定程度后，进程总是在等待调页完成，导致CPU利用率突然下降

#### 设备驱动与文件系统

​		中断处理（输入）、out（输出）、文件视图（接口）

​		驱动外设工作：CPU向控制器中的寄存器读写数据；控制器完成工作并向CPU发中断信号

​		

##### I/O与显示器

​		库函数（printf）-》系统调用（write）-》字符设备接口（crw_table[]）-》tty设备写（tty_write）-》显示器写（con_write）

​		写出核心out指令，将相应函数注册至表中，创建对应dev文件

##### 键盘

​		键盘中断-》read_q队列-》write_q队列-》con_write显示器写

​		键盘中断-》read_q队列-》secondary-》tty设备读（tty_read）-》字符设备接口（crw_table[]）

##### 磁盘管理

###### 		生磁盘的使用

​				磁盘I/O过程--控制器-》寻道-》旋转-》传输

​				直接使用磁盘--往控制器中写柱面C、磁头H、扇区S及缓存位置

​				第一层抽象--通过盘块号读写磁盘，驱动负责从block计算出CHS

​				第二层抽象--多个进程通过队列使用磁盘，磁盘调度进程队列申请

​							FCFS调度算法--先来先服务，磁头左右横跳

​							SSTF算法--短寻道优先，磁头中间徘徊，远处存在饥饿问题

​							SCAN算法--扫描算法，SSTF+中途不回折，直到一边边缘才回头走

​							C-SCAN--SCAN+走到边缘则直接跳到另一边缘开始走，电梯算法，到达底层，优先去接最高楼的人

​			总结：进程得到盘块号，算出扇区号-》扇区号make req，用电梯算法add_request-》进程sleep_on-》磁盘中断处理

###### 磁盘到文件

​			第三层抽象--文件：实现字符流到盘块号的映射。

​													顺序结构（文件的数据结构FCB中存放起始块及块数）

​													链式结构（FCB中存放文件名及起始块，还有一个指针指向下一块）

​													索引结构（FCB中存放文件名及索引块的地址）Linux使用多级索引，FCB为inode

###### 文件使用磁盘的实现

​			文件名-》inode-》数据盘块号

###### 目录与文件系统

​			第四层抽象--文件系统：抽象整个磁盘

​						目录：表示一个文件集合，通过目录-》文件FCB

​						树状目录的完整实现：磁盘分配为FCB数组和数据盘块集合，FCB数组中第零个存放根目录的FCB，根目录的FCB找到对应数据盘块，再由数据盘块中包含的目录项（文件名+对应FCB地址）结合FCB数组，找到目录项对应的数据盘块，依次类推。

​						磁盘分配：引导块、超级块、i节点位图、盘块位图、FCB数组及数据盘块集合。

磁盘使用完整映射：用户读test.c-》open(/xx/test.c)找到文件的inode-》read(fd)根据inode找到盘块-》写入电梯队列-》磁盘中断，计算柱面cyl，磁头head和扇区sector-》写磁盘控制器outp（cyl， head， sector）
